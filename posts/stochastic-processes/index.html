<!doctype html><html lang="en"><head><title data-react-helmet="true">Stochastic Processes as Monad Transformers</title><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta data-react-helmet="true" name="generator" content="Phenomic 0.21.1"/><meta data-react-helmet="true" property="og:site_name" content="random-agent"/><meta data-react-helmet="true" name="twitter:site" content="@rcalsaverini"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="Stochastic Processes as Monad Transformers"/><meta data-react-helmet="true" property="og:url" content="https://rcalsaverini.github.io/posts/stochastic-processes/"/><meta data-react-helmet="true" property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/3/31/Portal_Math_Banner_Background_ka.jpg"/><meta data-react-helmet="true" property="og:description" content="I have a difficulty to understand functional programming concepts that I can’t put to some very simple and natural use (natural for me, of…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="Stochastic Processes as Monad Transformers"/><meta data-react-helmet="true" name="twitter:creator" content="@rcalsaverini"/><meta data-react-helmet="true" name="twitter:description" content="I have a difficulty to understand functional programming concepts that I can’t put to some very simple and natural use (natural for me, of…"/><meta data-react-helmet="true" name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/3/31/Portal_Math_Banner_Background_ka.jpg"/><meta data-react-helmet="true" name="description" content="I have a difficulty to understand functional programming concepts that I can’t put to some very simple and natural use (natural for me, of…"/><link rel="stylesheet" href="/phenomic.browser.33704cfe8247d9bb8f33.css"/><script data-react-helmet="true" src="https://cdn.polyfill.io/v2/polyfill.min.js?features=es6&amp;flags=gated"></script><script data-react-helmet="true" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script></head><body><div id="phenomic"><div class="_2Mf6m" data-reactroot="" data-reactid="1" data-react-checksum="-1212258918"><div hidden="" data-reactid="2"><!-- react-empty: 3 --><!-- react-empty: 4 --><style data-reactid="5">@-ms-viewport { width: device-width; }</style></div><header class="_2gGRo" data-reactid="6"><nav class="_2frUm" data-reactid="7"><div class="_37D8R" data-reactid="8"><a class="Ezg15" href="/" data-reactid="9">Home</a></div><div class="_3VLYQ" data-reactid="10"><a href="https://twitter.com/rcalsaverini" class="Ezg15" data-reactid="11"><span class="SVGInline SVGInline--cleaned" data-reactid="12"><svg class="SVGInline-svg SVGInline--cleaned-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M24 4.557a9.83 9.83 0 0 1-2.828.775 4.932 4.932 0 0 0 2.165-2.724 9.864 9.864 0 0 1-3.127 1.195 4.916 4.916 0 0 0-3.594-1.555c-3.18 0-5.515 2.966-4.797 6.045A13.978 13.978 0 0 1 1.67 3.15a4.93 4.93 0 0 0 1.524 6.573 4.903 4.903 0 0 1-2.23-.616c-.053 2.28 1.582 4.415 3.95 4.89a4.935 4.935 0 0 1-2.224.084 4.928 4.928 0 0 0 4.6 3.42A9.9 9.9 0 0 1 0 19.54a13.94 13.94 0 0 0 7.548 2.212c9.142 0 14.307-7.72 13.995-14.646A10.025 10.025 0 0 0 24 4.556z"/></svg></span><!-- react-text: 13 -->Twitter<!-- /react-text --></a><a href="https://github.com/rcalsaverini/" class="Ezg15" data-reactid="14"><span class="SVGInline SVGInline--cleaned" data-reactid="15"><svg class="SVGInline-svg SVGInline--cleaned-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.238 1.84 1.238 1.07 1.834 2.806 1.304 3.49.997.108-.776.42-1.306.763-1.605-2.665-.305-5.467-1.334-5.467-5.93 0-1.312.47-2.382 1.236-3.222-.125-.303-.536-1.524.116-3.176 0 0 1.008-.322 3.3 1.23A11.51 11.51 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.29-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.236 1.91 1.236 3.22 0 4.61-2.807 5.625-5.48 5.922.43.372.824 1.102.824 2.222v3.293c0 .32.192.694.8.576C20.567 21.796 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></span><!-- react-text: 16 -->GitHub<!-- /react-text --></a></div></nav></header><div class="_116Tm" data-reactid="17"><div class="sFWsg" data-reactid="18"><!-- react-empty: 19 --><div class="_3p2ZP" style="background:#111 url(https://upload.wikimedia.org/wikipedia/commons/3/31/Portal_Math_Banner_Background_ka.jpg) 50% 50% / cover;" data-reactid="20"><div class="_3wrxV" data-reactid="21"><div class="hOK0m" data-reactid="22"><h1 class="_1Tkeg" data-reactid="23">Stochastic Processes as Monad Transformers</h1></div></div></div><div class="hOK0m _1z1n5" data-reactid="24"><div data-reactid="25"><header class="_2BJ2-" data-reactid="26"><time data-reactid="27">Mon Aug 02 2010</time></header></div><div class="_30RKo" data-reactid="28"><div class="phenomic-BodyContainer" data-reactid="29"><p>I have a difficulty to understand functional programming concepts that I can’t put to some very simple and natural use (natural for me, of course). I need to find the perfect simple example to implement to finally understand something. And I’m not a computer scientist, so things like parsers and compilers have very little appeal to me (probably because I don’t understand them…). I’m a physicist, so this drives me to look for physical problems that can be implemented in Haskell so I can understand some concepts.</p>
<p>Monad transformers still eludes me. But I think I finally got the perfect subject were I can understand them: stochastic processes! First some book keeping:</p>
<pre><code class="hljs language-haskell"><span class="hljs-keyword">import</span> Control.Monad.State
<span class="hljs-keyword">import</span> Control.Monad
<span class="hljs-keyword">import</span> Control.Monad.Rand</code></pre>
<p>Now, stochastic processes have characteristics related to two different monads. In one hand, they are dynamical processes, and the way to implement dynamics in Haskell is with state monads. For example, if I want to iterate the logistic map:</p>
<p>$$x_{t+1} = \alpha x_t\left(1-x_t\right)$$</p>
<p>I could do the following:</p>
<pre><code class="hljs language-haskell">  f :: <span class="hljs-type">Double</span> -> <span class="hljs-type">Double</span>
  f x = <span class="hljs-number">4</span>*x*(<span class="hljs-number">1</span>-x)

  logistic :: <span class="hljs-type">State</span> <span class="hljs-type">Double</span> <span class="hljs-type">Double</span>
  logistic = <span class="hljs-keyword">do</span> x0 &#x3C;- get
        <span class="hljs-keyword">let</span> x1 = f x
        put x1
        return x1
  runLogistic :: <span class="hljs-type">State</span> <span class="hljs-type">Double</span> [<span class="hljs-type">Double</span>]
  runLogistic n x0= evalState (replicateM n logistic) x0</code></pre>
<p>Running this on ghci would give you, for example:</p>
<pre><code class="hljs language-haskell">  *<span class="hljs-type">Main</span>> runLogistic <span class="hljs-number">5</span> <span class="hljs-number">0.2</span>
  [<span class="hljs-number">0.6400000000000001</span>,<span class="hljs-number">0.9215999999999999</span>,<span class="hljs-number">0.28901376000000045</span>, <span class="hljs-number">0.8219392261226504</span>,<span class="hljs-number">0.5854205387341</span>]</code></pre>
<p>So we can make the loose correspondence: dynamical system ↔ state monad.</p>
<p>On the other hand, stochastic processes are compositions of random variables, and this is done with the Rand monad (found in <code>Control.Monad.Random</code>). As an example, the Box-Muller formula tells us that, if I have two inpendent random variables \(x\) and \(y\), distributed uniformly between in the \([0, 1]\) interval, then, the expression:</p>
<p>$$\sqrt{-2\log(x)}\cos(2\pi y)$$</p>
<p>will be normally distributed. We can write then:</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">boxmuller</span> :: <span class="hljs-type">Double</span> -> <span class="hljs-type">Double</span> -> <span class="hljs-type">Double</span>
<span class="hljs-title">boxmuller</span> x y = sqrt(<span class="hljs-number">-2</span>*log x)*cos(<span class="hljs-number">2</span>*pi*y)

<span class="hljs-title">normal</span> :: <span class="hljs-type">Rand</span> <span class="hljs-type">StdGen</span> <span class="hljs-type">Double</span>  <span class="hljs-comment">-- normally distributed</span>
<span class="hljs-title">normal</span> = <span class="hljs-keyword">do</span> x &#x3C;- getRandom
            y &#x3C;- getRandom
            return $ boxmuller x y

<span class="hljs-title">normals</span> n = replicateM n normal <span class="hljs-comment">-- n independent samples from normal</span></code></pre>
<p>Running this function we get what we need:</p>
<pre><code class="hljs language-haskell">*<span class="hljs-type">Main</span>> (evalRand $ normals <span class="hljs-number">5</span>) (mkStdGen <span class="hljs-number">0</span>) =
[<span class="hljs-number">0.1600255836730147</span>,<span class="hljs-number">0.1575360140445035</span>,<span class="hljs-number">-1.595627933129274</span>,
<span class="hljs-number">-0.18196791439834512</span>,<span class="hljs-number">-1.082222285056746</span>]</code></pre>
<p>So what is a stochastic process? In very rough terms: is a dynamical system with random variables. So we need a way to make the <code>Rand</code> monad to talk nicely with the <code>State</code> monad. The way to do this is to use a monad transformer, in this case, the <code>StateT</code> transformer. Monad transformers allows you to combine the functionalities of two different monads. In the case of the <code>StateT</code> monads, they allow you to add a state to any other monad you want. In our case, we want to wrap the <code>Rand</code> monad inside a <code>StateT</code> transformer and work with things of type:</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">foo</span> ::  <span class="hljs-type">StateT</span> s (<span class="hljs-type">Rand</span> <span class="hljs-type">StdGen</span>) r</code></pre>
<p>This type represent a monad that can store a state with type s, like the state monad, and can generate random variables of type r, like the rand monad. In general we would have a type</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">foo2</span> ::(<span class="hljs-type">MonadTrans</span> t, <span class="hljs-type">Monad</span> m) => t m a</code></pre>
<p>In this case, <code>t = StateT s</code> and <code>m = Rand StdGen</code>. The class <code>MonadTrans</code> is defined in <code>Control.Monad.Trans</code>, and provides the function:</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">lift</span> :: (<span class="hljs-type">MonadTrans</span> t, <span class="hljs-type">Monad</span> m) => m a -> t m a</code></pre>
<p>In this case, <code>t</code> is itself a monad, and can be treated like one through the code. It works like this: inside a do expression you can use the <code>lift</code> function to access the inner monad. Things called with lift will operate in the inner monad. Things called without <code>lift</code> will operate in the outer monad.</p>
<p>So, suppose we want to simulate this very simple process:</p>
<p>$$x_{t+1} = x_t + \eta_t$$</p>
<p>where \(\eta_t\) is drawn from a normal distribution. We would do:</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">randomWalk</span> :: <span class="hljs-type">StateT</span> <span class="hljs-type">Double</span> (<span class="hljs-type">Rand</span> <span class="hljs-type">StdGen</span>) <span class="hljs-type">Double</span>
<span class="hljs-title">randomWalk</span> = <span class="hljs-keyword">do</span> eta &#x3C;- lift normal
                x &#x3C;- get
                <span class="hljs-keyword">let</span> x' = x + eta
                put x'
                return x'
<span class="hljs-title">runWalk</span> :: <span class="hljs-type">Int</span> -> <span class="hljs-type">Double</span> -> <span class="hljs-type">StdGen</span> -> [<span class="hljs-type">Double</span>]
<span class="hljs-title">runWalk</span> n x0 gen = evalRand (replicateM n $ evalStateT randomWalk x0) gen</code></pre>
<p>The <code>evalStateT</code> function is just evalState adapted to run a StateT monad. Running this on ghci we get:</p>
<pre><code class="hljs language-haskell"> *<span class="hljs-type">Main</span>> runWalk <span class="hljs-number">5</span> <span class="hljs-number">0.0</span> gen
[<span class="hljs-number">0.1600255836730147</span>,<span class="hljs-number">0.1575360140445035</span>,<span class="hljs-number">-1.595627933129274</span>,
<span class="hljs-number">-0.18196791439834512</span>,<span class="hljs-number">-1.082222285056746</span>]</code></pre>
<p>This is what we can accomplish: we can easily operate simultaneously with functions that expect a state monad, like put and get, we can unwrap things with <code>&#x3C;-</code> from the inner <code>Rand</code> monad by using <code>lift</code> , and we can return things to the state monad. We could have any monad inside the <code>StateT</code> transformer. For example, we could have another <code>State</code> monad. Here is a fancy implementation of the Fibonacci sequence using a <code>State</code> monad (that stores the last but one value in the sequence as its internal state) inside a <code>StateT</code> transfomer (that stores the last value of the sequence):</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">fancyFib</span> :: <span class="hljs-type">StateT</span> <span class="hljs-type">Int</span> (<span class="hljs-type">State</span> <span class="hljs-type">Int</span>) <span class="hljs-type">Int</span>
<span class="hljs-title">fancyFib</span> = <span class="hljs-keyword">do</span> old &#x3C;- lift get
              new &#x3C;- get
              <span class="hljs-keyword">let</span> new' = new + old
                  old' = new
              lift $ put old'
              put new'
              return new

<span class="hljs-title">fancyFibs</span> :: <span class="hljs-type">Int</span> -> <span class="hljs-type">StateT</span> <span class="hljs-type">Int</span> (<span class="hljs-type">State</span> <span class="hljs-type">Int</span>) [<span class="hljs-type">Int</span>]
<span class="hljs-title">fancyFibs</span> n = replicateM n fancyFibs</code></pre>
<p>And we can run this to get:</p>
<pre><code class="hljs language-haskell">*<span class="hljs-type">Main</span>> evalState (evalStateT (fancyFibs <span class="hljs-number">10</span>) <span class="hljs-number">1</span>) <span class="hljs-number">0</span>
[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">34</span>,<span class="hljs-number">55</span>]</code></pre>
</div></div><hr data-reactid="30"/><div data-reactid="31"><h2 class="_1vSY4" data-reactid="32">Latest Posts</h2><div data-reactid="33"><ul class="lfRQE" data-reactid="34"><li data-reactid="35"><div class="_1eeKI" data-reactid="36"><a class="_2mH_g" href="/posts/operational-semantics/" data-reactid="37">The Operational Semantics for Monads</a><div class="_2l2N1" data-reactid="38"><time data-reactid="39">Wed Aug 25 2010</time></div><div class="_1-sEy" data-reactid="40"><!-- react-text: 41 -->Disclaimer: this is an old blog post from a very old wordpress blog and may contain inacuracies. I reproduced it as is for sentimental…<!-- /react-text --><!-- react-text: 42 --> <!-- /react-text --></div><a class="niUXw" href="/posts/operational-semantics/" data-reactid="43"><span role="button" class="_1mmZb _1w6mX" data-reactid="44">Read More →</span></a></div></li><li data-reactid="45"><div class="_1eeKI" data-reactid="46"><a class="_2mH_g" href="/posts/stochastic-processes/" data-reactid="47">Stochastic Processes as Monad Transformers</a><div class="_2l2N1" data-reactid="48"><time data-reactid="49">Mon Aug 02 2010</time></div><div class="_1-sEy" data-reactid="50"><!-- react-text: 51 -->I have a difficulty to understand functional programming concepts that I can’t put to some very simple and natural use (natural for me, of…<!-- /react-text --><!-- react-text: 52 --> <!-- /react-text --></div><a class="niUXw" href="/posts/stochastic-processes/" data-reactid="53"><span role="button" class="_1mmZb _1w6mX" data-reactid="54">Read More →</span></a></div></li></ul></div></div></div></div></div><footer class="_1Ustb" data-reactid="55"><p data-reactid="56"><a href="https://phenomic.io" class="_21LuU" data-reactid="57"><!-- react-text: 58 -->Website generated with <!-- /react-text --><span class="MMp-P" data-reactid="59">&lt;Phenomic /&gt;</span></a></p></footer></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.7f6093458561a2a9bb2178ef2cba0f0f.json"},{"title":"About me","hero":"https://upload.wikimedia.org/wikipedia/commons/3/31/Portal_Math_Banner_Background_ka.jpg","description":"I am Rafael Calsaverini. This is my blog. * * * I like bayesian statistics, information theory, haskell programming and statistical…","__filename":"about.md","__url":"/about/","__resourceUrl":"/about/index.html","__dataUrl":"/about/index.html.dee8b5bc97512cbc60dbc7e12ba2f7c4.json"},{"title":"Random Agent","subtitle":"An entropy bounded utility maximizer.","layout":"Homepage","hero":"https://upload.wikimedia.org/wikipedia/commons/3/31/Portal_Math_Banner_Background_ka.jpg","cta":{"label":"About.","link":"about"},"description":"This is my personal webpage as blog. Welcome.","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.a9f9154f1f41a80a92fe2187b567b33a.json"},{"title":"The Operational Semantics for Monads","author":"Rafael S. Calsaverini","tags":"Haskell, Monads, Operational Monads, Free Vector Spaces","date":"2010-08-26T00:00:00.000Z","layout":"Post","hero":"https://upload.wikimedia.org/wikipedia/commons/3/31/Portal_Math_Banner_Background_ka.jpg","description":"Disclaimer: this is an old blog post from a very old wordpress blog and may contain inacuracies. I reproduced it as is for sentimental…","__filename":"posts/operational-semantics.md","__url":"/posts/operational-semantics/","__resourceUrl":"/posts/operational-semantics/index.html","__dataUrl":"/posts/operational-semantics/index.html.4815e748ec87e2665e5715fbb8b42b9c.json"},{"title":"Stochastic Processes as Monad Transformers","author":"Rafael S. Calsaverini","date":"2010-08-03T00:00:00.000Z","layout":"Post","hero":"https://upload.wikimedia.org/wikipedia/commons/3/31/Portal_Math_Banner_Background_ka.jpg","tags":"Haskell, Monad Transformers, Monads, Tutorial, Stochastic Processes","description":"I have a difficulty to understand functional programming concepts that I can’t put to some very simple and natural use (natural for me, of…","__filename":"posts/stochastic-processes.md","__url":"/posts/stochastic-processes/","__resourceUrl":"/posts/stochastic-processes/index.html","__dataUrl":"/posts/stochastic-processes/index.html.957de5fb81a2e5a71a52b22b1de4a1bb.json"}];window.__INITIAL_STATE__ = {"pages":{"/posts/stochastic-processes/":{"head":{"title":"Stochastic Processes as Monad Transformers","author":"Rafael S. Calsaverini","date":"2010-08-03T00:00:00.000Z","layout":"Post","hero":"https://upload.wikimedia.org/wikipedia/commons/3/31/Portal_Math_Banner_Background_ka.jpg","tags":"Haskell, Monad Transformers, Monads, Tutorial, Stochastic Processes","description":"I have a difficulty to understand functional programming concepts that I can’t put to some very simple and natural use (natural for me, of…"},"body":"<p>I have a difficulty to understand functional programming concepts that I can’t put to some very simple and natural use (natural for me, of course). I need to find the perfect simple example to implement to finally understand something. And I’m not a computer scientist, so things like parsers and compilers have very little appeal to me (probably because I don’t understand them…). I’m a physicist, so this drives me to look for physical problems that can be implemented in Haskell so I can understand some concepts.</p>\n<p>Monad transformers still eludes me. But I think I finally got the perfect subject were I can understand them: stochastic processes! First some book keeping:</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-keyword\">import</span> Control.Monad.State\n<span class=\"hljs-keyword\">import</span> Control.Monad\n<span class=\"hljs-keyword\">import</span> Control.Monad.Rand</code></pre>\n<p>Now, stochastic processes have characteristics related to two different monads. In one hand, they are dynamical processes, and the way to implement dynamics in Haskell is with state monads. For example, if I want to iterate the logistic map:</p>\n<p>$$x_{t+1} = \\alpha x_t\\left(1-x_t\\right)$$</p>\n<p>I could do the following:</p>\n<pre><code class=\"hljs language-haskell\">  f :: <span class=\"hljs-type\">Double</span> -> <span class=\"hljs-type\">Double</span>\n  f x = <span class=\"hljs-number\">4</span>*x*(<span class=\"hljs-number\">1</span>-x)\n\n  logistic :: <span class=\"hljs-type\">State</span> <span class=\"hljs-type\">Double</span> <span class=\"hljs-type\">Double</span>\n  logistic = <span class=\"hljs-keyword\">do</span> x0 &#x3C;- get\n        <span class=\"hljs-keyword\">let</span> x1 = f x\n        put x1\n        return x1\n  runLogistic :: <span class=\"hljs-type\">State</span> <span class=\"hljs-type\">Double</span> [<span class=\"hljs-type\">Double</span>]\n  runLogistic n x0= evalState (replicateM n logistic) x0</code></pre>\n<p>Running this on ghci would give you, for example:</p>\n<pre><code class=\"hljs language-haskell\">  *<span class=\"hljs-type\">Main</span>> runLogistic <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">0.2</span>\n  [<span class=\"hljs-number\">0.6400000000000001</span>,<span class=\"hljs-number\">0.9215999999999999</span>,<span class=\"hljs-number\">0.28901376000000045</span>, <span class=\"hljs-number\">0.8219392261226504</span>,<span class=\"hljs-number\">0.5854205387341</span>]</code></pre>\n<p>So we can make the loose correspondence: dynamical system ↔ state monad.</p>\n<p>On the other hand, stochastic processes are compositions of random variables, and this is done with the Rand monad (found in <code>Control.Monad.Random</code>). As an example, the Box-Muller formula tells us that, if I have two inpendent random variables \\(x\\) and \\(y\\), distributed uniformly between in the \\([0, 1]\\) interval, then, the expression:</p>\n<p>$$\\sqrt{-2\\log(x)}\\cos(2\\pi y)$$</p>\n<p>will be normally distributed. We can write then:</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-title\">boxmuller</span> :: <span class=\"hljs-type\">Double</span> -> <span class=\"hljs-type\">Double</span> -> <span class=\"hljs-type\">Double</span>\n<span class=\"hljs-title\">boxmuller</span> x y = sqrt(<span class=\"hljs-number\">-2</span>*log x)*cos(<span class=\"hljs-number\">2</span>*pi*y)\n\n<span class=\"hljs-title\">normal</span> :: <span class=\"hljs-type\">Rand</span> <span class=\"hljs-type\">StdGen</span> <span class=\"hljs-type\">Double</span>  <span class=\"hljs-comment\">-- normally distributed</span>\n<span class=\"hljs-title\">normal</span> = <span class=\"hljs-keyword\">do</span> x &#x3C;- getRandom\n            y &#x3C;- getRandom\n            return $ boxmuller x y\n\n<span class=\"hljs-title\">normals</span> n = replicateM n normal <span class=\"hljs-comment\">-- n independent samples from normal</span></code></pre>\n<p>Running this function we get what we need:</p>\n<pre><code class=\"hljs language-haskell\">*<span class=\"hljs-type\">Main</span>> (evalRand $ normals <span class=\"hljs-number\">5</span>) (mkStdGen <span class=\"hljs-number\">0</span>) =\n[<span class=\"hljs-number\">0.1600255836730147</span>,<span class=\"hljs-number\">0.1575360140445035</span>,<span class=\"hljs-number\">-1.595627933129274</span>,\n<span class=\"hljs-number\">-0.18196791439834512</span>,<span class=\"hljs-number\">-1.082222285056746</span>]</code></pre>\n<p>So what is a stochastic process? In very rough terms: is a dynamical system with random variables. So we need a way to make the <code>Rand</code> monad to talk nicely with the <code>State</code> monad. The way to do this is to use a monad transformer, in this case, the <code>StateT</code> transformer. Monad transformers allows you to combine the functionalities of two different monads. In the case of the <code>StateT</code> monads, they allow you to add a state to any other monad you want. In our case, we want to wrap the <code>Rand</code> monad inside a <code>StateT</code> transformer and work with things of type:</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-title\">foo</span> ::  <span class=\"hljs-type\">StateT</span> s (<span class=\"hljs-type\">Rand</span> <span class=\"hljs-type\">StdGen</span>) r</code></pre>\n<p>This type represent a monad that can store a state with type s, like the state monad, and can generate random variables of type r, like the rand monad. In general we would have a type</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-title\">foo2</span> ::(<span class=\"hljs-type\">MonadTrans</span> t, <span class=\"hljs-type\">Monad</span> m) => t m a</code></pre>\n<p>In this case, <code>t = StateT s</code> and <code>m = Rand StdGen</code>. The class <code>MonadTrans</code> is defined in <code>Control.Monad.Trans</code>, and provides the function:</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-title\">lift</span> :: (<span class=\"hljs-type\">MonadTrans</span> t, <span class=\"hljs-type\">Monad</span> m) => m a -> t m a</code></pre>\n<p>In this case, <code>t</code> is itself a monad, and can be treated like one through the code. It works like this: inside a do expression you can use the <code>lift</code> function to access the inner monad. Things called with lift will operate in the inner monad. Things called without <code>lift</code> will operate in the outer monad.</p>\n<p>So, suppose we want to simulate this very simple process:</p>\n<p>$$x_{t+1} = x_t + \\eta_t$$</p>\n<p>where \\(\\eta_t\\) is drawn from a normal distribution. We would do:</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-title\">randomWalk</span> :: <span class=\"hljs-type\">StateT</span> <span class=\"hljs-type\">Double</span> (<span class=\"hljs-type\">Rand</span> <span class=\"hljs-type\">StdGen</span>) <span class=\"hljs-type\">Double</span>\n<span class=\"hljs-title\">randomWalk</span> = <span class=\"hljs-keyword\">do</span> eta &#x3C;- lift normal\n                x &#x3C;- get\n                <span class=\"hljs-keyword\">let</span> x' = x + eta\n                put x'\n                return x'\n<span class=\"hljs-title\">runWalk</span> :: <span class=\"hljs-type\">Int</span> -> <span class=\"hljs-type\">Double</span> -> <span class=\"hljs-type\">StdGen</span> -> [<span class=\"hljs-type\">Double</span>]\n<span class=\"hljs-title\">runWalk</span> n x0 gen = evalRand (replicateM n $ evalStateT randomWalk x0) gen</code></pre>\n<p>The <code>evalStateT</code> function is just evalState adapted to run a StateT monad. Running this on ghci we get:</p>\n<pre><code class=\"hljs language-haskell\"> *<span class=\"hljs-type\">Main</span>> runWalk <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">0.0</span> gen\n[<span class=\"hljs-number\">0.1600255836730147</span>,<span class=\"hljs-number\">0.1575360140445035</span>,<span class=\"hljs-number\">-1.595627933129274</span>,\n<span class=\"hljs-number\">-0.18196791439834512</span>,<span class=\"hljs-number\">-1.082222285056746</span>]</code></pre>\n<p>This is what we can accomplish: we can easily operate simultaneously with functions that expect a state monad, like put and get, we can unwrap things with <code>&#x3C;-</code> from the inner <code>Rand</code> monad by using <code>lift</code> , and we can return things to the state monad. We could have any monad inside the <code>StateT</code> transformer. For example, we could have another <code>State</code> monad. Here is a fancy implementation of the Fibonacci sequence using a <code>State</code> monad (that stores the last but one value in the sequence as its internal state) inside a <code>StateT</code> transfomer (that stores the last value of the sequence):</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-title\">fancyFib</span> :: <span class=\"hljs-type\">StateT</span> <span class=\"hljs-type\">Int</span> (<span class=\"hljs-type\">State</span> <span class=\"hljs-type\">Int</span>) <span class=\"hljs-type\">Int</span>\n<span class=\"hljs-title\">fancyFib</span> = <span class=\"hljs-keyword\">do</span> old &#x3C;- lift get\n              new &#x3C;- get\n              <span class=\"hljs-keyword\">let</span> new' = new + old\n                  old' = new\n              lift $ put old'\n              put new'\n              return new\n\n<span class=\"hljs-title\">fancyFibs</span> :: <span class=\"hljs-type\">Int</span> -> <span class=\"hljs-type\">StateT</span> <span class=\"hljs-type\">Int</span> (<span class=\"hljs-type\">State</span> <span class=\"hljs-type\">Int</span>) [<span class=\"hljs-type\">Int</span>]\n<span class=\"hljs-title\">fancyFibs</span> n = replicateM n fancyFibs</code></pre>\n<p>And we can run this to get:</p>\n<pre><code class=\"hljs language-haskell\">*<span class=\"hljs-type\">Main</span>> evalState (evalStateT (fancyFibs <span class=\"hljs-number\">10</span>) <span class=\"hljs-number\">1</span>) <span class=\"hljs-number\">0</span>\n[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">13</span>,<span class=\"hljs-number\">21</span>,<span class=\"hljs-number\">34</span>,<span class=\"hljs-number\">55</span>]</code></pre>\n","__filename":"posts/stochastic-processes.md","__url":"/posts/stochastic-processes/","__resourceUrl":"/posts/stochastic-processes/index.html","__dataUrl":"/posts/stochastic-processes/index.html.957de5fb81a2e5a71a52b22b1de4a1bb.json","type":"Post"}}}</script><script src="/phenomic.browser.33704cfe8247d9bb8f33.js"></script></body></html>